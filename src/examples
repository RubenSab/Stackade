# count from 0 to 10

0
{
    (dup 10 <=)
    (dup print " " print (1 +) self) # true
    ("done!" print)                  # false
}


# identity matrix

"printMatrix" (

    "n" swap :num
    "i" 0 :num
    "j" 0 :num

    {
        (i n <)
        (
            {
                (j n <)
                ({(i j ==)(1)(0)} print " " print j ++ self)
                (j 0 =)
            }

            "\n" print
            i ++
            self
        )
    }
) :seq

10 printMatrix

"diagonalsMatrix" (

    "size" swap :num
    "i" 0 :num
    "j" 0 :num

    {
        (i size <)
        (
            {(j size <)
                ({(i j == i    j + size 1 - ==    or)
                    ({(i j == i    j + size 1 - ==    and)
                        ("o")
                        (size)
                    })
                    (" ")}
                print " " print j ++ self)
                (j 0 =)}

            "\n" print
            i ++
            self
        )
    }
) :seq

7 diagonalsMatrix


"n" 1 :num              # define n = 1
"pointer" n :ref        # define a pointer to n
pointer get 2 + print   # get the value of pointer and add 2
"pointer" :del          # just like any other variable, pointers can be deleted from namespace
debug halt


# Circular reference

"B" A :ref   # define a reference B to a yet unexisting A variable
"A" B :ref   # define a reference A to B

debug halt


# Casting

"A" 3 :num
A toStr print

"\n" print

"B" "5.2" :str
B toNum print


"listPut" (
    "value" swap :num    # the arguments are taken in reverse order because of how they get pushed on the stack
    "index" swap :num
    "listName" swap :str

    "elementName" listName "-" cat   index numToStr cat   :str   # assemble element name (example: newList.0)
    elementName refGet value refGet :box                 # assign value to the new list element name

    elementName refGet   # get elementName's content (so the name of the new list element)
    :raiseName           # raise it to caller's namespace before this sequence's namespace collapses

) :seq


"geti" (
    "index" swap :num
    "name" swap :str

    name "-" cat  index numToStr   cat strGet unbox
) :seq

# test

"listTest" 0 42 listPut
"listTest" 0 geti print
debug


# input

input strToNum {(0 >)("y")("n")} print


# reverse string and Sdoc

# reverseStr: reverses a string
# args:
# 0: (str) input string
# returns:
# 0: (str) reversed string

"reverseStr" (
    "originalStr" swap :str   # take s(0) as input

    ""   # add an empty string to the stack

    "i" originalStr strLen 1 - :num    # initialize a counter at input string's length - 1
    {
        (i 0 >=)
        (
            originalStr i strAt strCat   # get input string's character at i
            i--   # decrease counter by one
            self
        )
    }
) :seq

input reverseStr print


"++" (
    dup dup refName swap 1 + :num :raise
) :seq

"nextFibo" (dup rot +) :seq

"fibonacci" (
    "n" swap :num
    {
        (n 2 <)
        (1 dup print "\n" print)
        (
            1 1
            "i" 0 :num
            {
                (i n 2 - <=)
                (nextFibo i ++
                dup print "\n" print
                self)
            }
        )
    }
) :seq

500 fibonacci
debug


"circularRef" (
    "bName" swap :str  # get 2nd variable name and store it into bName
    "aName" swap :str  # get 1st variable name and store it into aName

    aName refGet            # get the content of aName
    bName refGet strToRef   # get the content of bName and transform it into a reference to an undefined variable named as the content of bName
    :ref                    # define a reference named as the content of aName (from line 5), referencing to the reference from line 6

    bName refGet            # get the content of bName
    aName refGet strToRef   # get the content of aName and transform it into a reference to an undefined variable named as the content of aName
    :ref                    # define a reference named as the content of bName (from line 9), referencing to the reference from line 10

    aName strToRef :raise   # raise the variable named as the content of aName to caller's namespace
    bName strToRef :raise   # raise the variable named as the content of bName to caller's namespace

) :seq

"a" "b" circularRef
"a = " print a print "\n" print
"b = " print b print "\n" print